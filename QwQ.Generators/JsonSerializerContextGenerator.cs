using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace QwQ.Generators;

[Generator]
#pragma warning disable RS1036
public class JsonSerializerContextGenerator : IIncrementalGenerator
#pragma warning restore RS1036
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 注册一个语法接收器，用于收集所有类声明
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax, // 筛选类声明
                static (context, _) => context.Node as ClassDeclarationSyntax) // 提取类声明
            .Where(static syntax => syntax != null); // 过滤掉空值

        // 合并语法树与编译上下文
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // 注册执行逻辑
        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
        {
            var (compilation, classes) = source;

            // 获取关键符号
            var jsonOptionsAttributeSymbol = compilation.GetTypeByMetadataName(
                "System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute");

            var jsonSerializableAttributeSymbol = compilation.GetTypeByMetadataName(
                "System.Text.Json.Serialization.JsonSerializableAttribute");

            if (jsonOptionsAttributeSymbol == null || jsonSerializableAttributeSymbol == null)
            {
                spc.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "JSCG001",
                        "缺少依赖",
                        "目标项目未引用 System.Text.Json 或版本低于 6.0",
                        "JsonSerializerContextGenerator",
                        DiagnosticSeverity.Error,
                        true),
                    Location.None));
                return;
            }

            var typesToGenerate = new List<(INamedTypeSymbol Type, string OptionsCode)>();

            foreach (var classDecl in classes)
            {
                if (classDecl != null)
                {
                    var semanticModel = compilation.GetSemanticModel(classDecl.SyntaxTree);
                    if (semanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol typeSymbol) continue;
                    var generateAttribute = typeSymbol.GetAttributes()
                        .FirstOrDefault(attr => attr.AttributeClass?.Name == "GenerateJsonSerializerContextAttribute");

                    if (generateAttribute == null) continue;

                    // 解析选项参数
                    string optionsCode = "WriteIndented = true"; // 默认值
                    foreach (var arg in generateAttribute.NamedArguments)
                    {
                        if (arg is { Key: "Options", Value.Value: AttributeData optionsAttr })
                        {
                            optionsCode = ParseOptionsAttribute(optionsAttr);
                        }
                    }

                    foreach (var ctorArg in generateAttribute.ConstructorArguments.Where(ctorArg => ctorArg.Type != null && ctorArg.Type.Equals(jsonOptionsAttributeSymbol, SymbolEqualityComparer.Default)))
                    {
                        optionsCode = ParseOptionsAttribute(ctorArg.Value as AttributeData);
                    }

                    typesToGenerate.Add((typeSymbol, optionsCode));
                }

            }

            if (!typesToGenerate.Any()) return;
            string sourceCode = GenerateJsonSerializerContextClass(typesToGenerate);
            spc.AddSource("AutoGeneratedJsonSerializerContext.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        });
    }

    private static string ParseOptionsAttribute(AttributeData? optionsAttr)
    {
        if (optionsAttr == null) return "WriteIndented = true";

        var sb = new StringBuilder();
        foreach (var arg in optionsAttr.ConstructorArguments)
        {
            sb.Append(arg.Type is { SpecialType: SpecialType.System_Boolean } ? $"{arg.Type.Name} = {arg.Value?.ToString()?.ToLower()}, " : $"{arg.Type?.Name} = {arg.Value}, ");
        }

        return sb.ToString().TrimEnd(',', ' ');
    }

    private static string GenerateJsonSerializerContextClass(
        List<(INamedTypeSymbol Type, string OptionsCode)> types
        )
    {
        var sb = new StringBuilder();
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Text.Json.Serialization.Metadata;");
        sb.AppendLine();

        // 应用全局配置
        string firstOptions = types.First().OptionsCode;
        sb.AppendLine($"[JsonSourceGenerationOptions({firstOptions})]");

        // 标记所有需要序列化的类型
        foreach (var type in types)
        {
            sb.AppendLine($"[JsonSerializable(typeof({type.Type.ToDisplayString()}))]");
        }

        // 生成上下文类
        sb.AppendLine("internal partial class AutoGeneratedJsonSerializerContext : JsonSerializerContext");
        sb.AppendLine("{");
        sb.AppendLine("    // 自动生成的代码");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
